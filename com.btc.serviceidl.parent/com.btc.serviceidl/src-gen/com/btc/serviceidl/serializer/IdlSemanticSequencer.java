/*
 * generated by Xtext 2.13.0
 */
package com.btc.serviceidl.serializer;

import com.btc.serviceidl.idl.AbstractType;
import com.btc.serviceidl.idl.AliasDeclaration;
import com.btc.serviceidl.idl.DocCommentElement;
import com.btc.serviceidl.idl.EnumDeclaration;
import com.btc.serviceidl.idl.EventDeclaration;
import com.btc.serviceidl.idl.ExceptionDeclaration;
import com.btc.serviceidl.idl.ExceptionReferenceDeclaration;
import com.btc.serviceidl.idl.FunctionDeclaration;
import com.btc.serviceidl.idl.IDLSpecification;
import com.btc.serviceidl.idl.IdlPackage;
import com.btc.serviceidl.idl.ImportDeclaration;
import com.btc.serviceidl.idl.InterfaceDeclaration;
import com.btc.serviceidl.idl.KeyElement;
import com.btc.serviceidl.idl.MemberElement;
import com.btc.serviceidl.idl.ModuleDeclaration;
import com.btc.serviceidl.idl.ParameterElement;
import com.btc.serviceidl.idl.PrimitiveType;
import com.btc.serviceidl.idl.ReturnTypeElement;
import com.btc.serviceidl.idl.SequenceDeclaration;
import com.btc.serviceidl.idl.StructDeclaration;
import com.btc.serviceidl.idl.TupleDeclaration;
import com.btc.serviceidl.idl.TypicalLengthHint;
import com.btc.serviceidl.idl.TypicalSizeHint;
import com.btc.serviceidl.services.IdlGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IdlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IdlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IdlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IdlPackage.ABSTRACT_TYPE:
				sequence_AbstractType(context, (AbstractType) semanticObject); 
				return; 
			case IdlPackage.ALIAS_DECLARATION:
				sequence_AliasDeclaration(context, (AliasDeclaration) semanticObject); 
				return; 
			case IdlPackage.DOC_COMMENT_ELEMENT:
				sequence_DocCommentElement(context, (DocCommentElement) semanticObject); 
				return; 
			case IdlPackage.ENUM_DECLARATION:
				sequence_EnumDeclaration(context, (EnumDeclaration) semanticObject); 
				return; 
			case IdlPackage.EVENT_DECLARATION:
				sequence_EventDeclaration(context, (EventDeclaration) semanticObject); 
				return; 
			case IdlPackage.EXCEPTION_DECLARATION:
				sequence_ExceptionDeclaration(context, (ExceptionDeclaration) semanticObject); 
				return; 
			case IdlPackage.EXCEPTION_REFERENCE_DECLARATION:
				sequence_ExceptionReferenceDeclaration(context, (ExceptionReferenceDeclaration) semanticObject); 
				return; 
			case IdlPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case IdlPackage.IDL_SPECIFICATION:
				sequence_IDLSpecification(context, (IDLSpecification) semanticObject); 
				return; 
			case IdlPackage.IMPORT_DECLARATION:
				sequence_ImportDeclaration(context, (ImportDeclaration) semanticObject); 
				return; 
			case IdlPackage.INTERFACE_DECLARATION:
				sequence_InterfaceDeclaration(context, (InterfaceDeclaration) semanticObject); 
				return; 
			case IdlPackage.KEY_ELEMENT:
				sequence_KeyElement(context, (KeyElement) semanticObject); 
				return; 
			case IdlPackage.MEMBER_ELEMENT:
				sequence_MemberElement(context, (MemberElement) semanticObject); 
				return; 
			case IdlPackage.MODULE_DECLARATION:
				sequence_ModuleDeclaration(context, (ModuleDeclaration) semanticObject); 
				return; 
			case IdlPackage.PARAMETER_ELEMENT:
				sequence_ParameterElement(context, (ParameterElement) semanticObject); 
				return; 
			case IdlPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case IdlPackage.RETURN_TYPE_ELEMENT:
				sequence_ReturnTypeElement(context, (ReturnTypeElement) semanticObject); 
				return; 
			case IdlPackage.SEQUENCE_DECLARATION:
				sequence_SequenceDeclaration(context, (SequenceDeclaration) semanticObject); 
				return; 
			case IdlPackage.STRUCT_DECLARATION:
				sequence_StructDeclaration(context, (StructDeclaration) semanticObject); 
				return; 
			case IdlPackage.TUPLE_DECLARATION:
				sequence_TupleDeclaration(context, (TupleDeclaration) semanticObject); 
				return; 
			case IdlPackage.TYPICAL_LENGTH_HINT:
				sequence_TypicalLengthHint(context, (TypicalLengthHint) semanticObject); 
				return; 
			case IdlPackage.TYPICAL_SIZE_HINT:
				sequence_TypicalSizeHint(context, (TypicalSizeHint) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractType returns AbstractType
	 *     ReturnTypeElement returns AbstractType
	 *
	 * Constraint:
	 *     (primitiveType=PrimitiveType | referenceType=[AbstractCrossReference|QualifiedName] | collectionType=AbstractCollection)
	 */
	protected void sequence_AbstractType(ISerializationContext context, AbstractType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModuleComponent returns AliasDeclaration
	 *     AbstractTypeDeclaration returns AliasDeclaration
	 *     AbstractCrossReference returns AliasDeclaration
	 *     AliasDeclaration returns AliasDeclaration
	 *     AbstractInterfaceComponent returns AliasDeclaration
	 *
	 * Constraint:
	 *     (type=AbstractType name=ID)
	 */
	protected void sequence_AliasDeclaration(ISerializationContext context, AliasDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.ALIAS_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.ALIAS_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.ALIAS_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.ALIAS_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasDeclarationAccess().getTypeAbstractTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAliasDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DocCommentElement returns DocCommentElement
	 *
	 * Constraint:
	 *     (text=SL_DOC_COMMENT | text=ML_DOC_COMMENT)
	 */
	protected void sequence_DocCommentElement(ISerializationContext context, DocCommentElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModuleComponent returns EnumDeclaration
	 *     AbstractTypeDeclaration returns EnumDeclaration
	 *     AbstractCrossReference returns EnumDeclaration
	 *     EnumDeclaration returns EnumDeclaration
	 *     AbstractInterfaceComponent returns EnumDeclaration
	 *
	 * Constraint:
	 *     (name=ID containedIdentifiers+=ID containedIdentifiers+=ID* declarator=ID?)
	 */
	protected void sequence_EnumDeclaration(ISerializationContext context, EnumDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractInterfaceComponent returns EventDeclaration
	 *     EventDeclaration returns EventDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         guid=UUID_LITERAL? 
	 *         data=[StructDeclaration|QualifiedName] 
	 *         (keys+=KeyElement keys+=KeyElement*)? 
	 *         (raisedExceptions+=[AbstractException|QualifiedName] raisedExceptions+=[AbstractException|QualifiedName]*)?
	 *     )
	 */
	protected void sequence_EventDeclaration(ISerializationContext context, EventDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModuleComponent returns ExceptionDeclaration
	 *     AbstractException returns ExceptionDeclaration
	 *     ExceptionDeclaration returns ExceptionDeclaration
	 *     AbstractTypeDeclaration returns ExceptionDeclaration
	 *     AbstractCrossReference returns ExceptionDeclaration
	 *     AbstractInterfaceComponent returns ExceptionDeclaration
	 *
	 * Constraint:
	 *     (name=ID supertype=[AbstractException|QualifiedName]? members+=MemberElement*)
	 */
	protected void sequence_ExceptionDeclaration(ISerializationContext context, ExceptionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModuleComponent returns ExceptionReferenceDeclaration
	 *     AbstractException returns ExceptionReferenceDeclaration
	 *     ExceptionReferenceDeclaration returns ExceptionReferenceDeclaration
	 *     AbstractTypeDeclaration returns ExceptionReferenceDeclaration
	 *     AbstractCrossReference returns ExceptionReferenceDeclaration
	 *     AbstractInterfaceComponent returns ExceptionReferenceDeclaration
	 *
	 * Constraint:
	 *     (name=ID location=STRING)
	 */
	protected void sequence_ExceptionReferenceDeclaration(ISerializationContext context, ExceptionReferenceDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.ABSTRACT_EXCEPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.ABSTRACT_EXCEPTION__NAME));
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.EXCEPTION_REFERENCE_DECLARATION__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.EXCEPTION_REFERENCE_DECLARATION__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExceptionReferenceDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExceptionReferenceDeclarationAccess().getLocationSTRINGTerminalRuleCall_3_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractInterfaceComponent returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (
	 *         docComments+=DocCommentElement* 
	 *         sync?='sync'? 
	 *         query?='query'? 
	 *         name=ID 
	 *         (parameters+=ParameterElement parameters+=ParameterElement*)? 
	 *         injected?='injectable'? 
	 *         returnedType=ReturnTypeElement 
	 *         (raisedExceptions+=[AbstractException|QualifiedName] raisedExceptions+=[AbstractException|QualifiedName]*)?
	 *     )
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IDLSpecification returns IDLSpecification
	 *
	 * Constraint:
	 *     ((importedEntities+=ImportDeclaration+ modules+=ModuleDeclaration+) | modules+=ModuleDeclaration+)?
	 */
	protected void sequence_IDLSpecification(ISerializationContext context, IDLSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDeclaration returns ImportDeclaration
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_ImportDeclaration(ISerializationContext context, ImportDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.IMPORT_DECLARATION__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.IMPORT_DECLARATION__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportDeclarationAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModuleComponent returns InterfaceDeclaration
	 *     InterfaceDeclaration returns InterfaceDeclaration
	 *
	 * Constraint:
	 *     (
	 *         docComments+=DocCommentElement* 
	 *         abstract?='abstract'? 
	 *         name=ID 
	 *         (version=VERSION | guid=UUID_LITERAL)* 
	 *         (derivesFrom+=[InterfaceDeclaration|QualifiedName] derivesFrom+=[InterfaceDeclaration|QualifiedName]*)? 
	 *         contains+=AbstractInterfaceComponent*
	 *     )
	 */
	protected void sequence_InterfaceDeclaration(ISerializationContext context, InterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyElement returns KeyElement
	 *
	 * Constraint:
	 *     (type=AbstractType keyName=ID)
	 */
	protected void sequence_KeyElement(ISerializationContext context, KeyElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.KEY_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.KEY_ELEMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.KEY_ELEMENT__KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.KEY_ELEMENT__KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyElementAccess().getTypeAbstractTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getKeyElementAccess().getKeyNameIDTerminalRuleCall_1_0(), semanticObject.getKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MemberElement returns MemberElement
	 *
	 * Constraint:
	 *     (optional?='optional'? type=AbstractType name=ID)
	 */
	protected void sequence_MemberElement(ISerializationContext context, MemberElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleDeclaration returns ModuleDeclaration
	 *
	 * Constraint:
	 *     (virtual?='virtual'? main?='main'? name=ID moduleComponents+=AbstractModuleComponent* nestedModules+=ModuleDeclaration*)
	 */
	protected void sequence_ModuleDeclaration(ISerializationContext context, ModuleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterElement returns ParameterElement
	 *
	 * Constraint:
	 *     (direction=ParameterDirection paramType=AbstractType paramName=ID)
	 */
	protected void sequence_ParameterElement(ISerializationContext context, ParameterElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.PARAMETER_ELEMENT__DIRECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.PARAMETER_ELEMENT__DIRECTION));
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.PARAMETER_ELEMENT__PARAM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.PARAMETER_ELEMENT__PARAM_TYPE));
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.PARAMETER_ELEMENT__PARAM_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.PARAMETER_ELEMENT__PARAM_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterElementAccess().getDirectionParameterDirectionEnumRuleCall_0_0(), semanticObject.getDirection());
		feeder.accept(grammarAccess.getParameterElementAccess().getParamTypeAbstractTypeParserRuleCall_1_0(), semanticObject.getParamType());
		feeder.accept(grammarAccess.getParameterElementAccess().getParamNameIDTerminalRuleCall_2_0(), semanticObject.getParamName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     (
	 *         integerType=IntegerType | 
	 *         stringType=STRINGTYPE | 
	 *         charType=CHAR | 
	 *         floatingPointType=FloatingPointType | 
	 *         uuidType=UUID | 
	 *         booleanType=BOOLEAN
	 *     )
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnTypeElement returns ReturnTypeElement
	 *
	 * Constraint:
	 *     void?='void'
	 */
	protected void sequence_ReturnTypeElement(ISerializationContext context, ReturnTypeElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.RETURN_TYPE_ELEMENT__VOID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.RETURN_TYPE_ELEMENT__VOID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnTypeElementAccess().getVoidVoidKeyword_1_0(), semanticObject.isVoid());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCrossReference returns SequenceDeclaration
	 *     AbstractCollection returns SequenceDeclaration
	 *     SequenceDeclaration returns SequenceDeclaration
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             type=AbstractType | 
	 *             (
	 *                 failable?='failable' 
	 *                 type=AbstractType 
	 *                 (raisedExceptions+=[AbstractException|QualifiedName] raisedExceptions+=[AbstractException|QualifiedName]*)?
	 *             )
	 *         ) 
	 *         (sequenceHints+=AbstractSequenceHint sequenceHints+=AbstractSequenceHint*)?
	 *     )
	 */
	protected void sequence_SequenceDeclaration(ISerializationContext context, SequenceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModuleComponent returns StructDeclaration
	 *     AbstractTypeDeclaration returns StructDeclaration
	 *     AbstractCrossReference returns StructDeclaration
	 *     StructDeclaration returns StructDeclaration
	 *     AbstractInterfaceComponent returns StructDeclaration
	 *
	 * Constraint:
	 *     (name=ID supertype=[StructDeclaration|QualifiedName]? (members+=MemberElement | typeDecls+=AbstractTypeDeclaration)* declarator=ID?)
	 */
	protected void sequence_StructDeclaration(ISerializationContext context, StructDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCrossReference returns TupleDeclaration
	 *     AbstractCollection returns TupleDeclaration
	 *     TupleDeclaration returns TupleDeclaration
	 *
	 * Constraint:
	 *     (types+=AbstractType types+=AbstractType*)
	 */
	protected void sequence_TupleDeclaration(ISerializationContext context, TupleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractSequenceHint returns TypicalLengthHint
	 *     TypicalLengthHint returns TypicalLengthHint
	 *
	 * Constraint:
	 *     length=INT
	 */
	protected void sequence_TypicalLengthHint(ISerializationContext context, TypicalLengthHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.TYPICAL_LENGTH_HINT__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.TYPICAL_LENGTH_HINT__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypicalLengthHintAccess().getLengthINTTerminalRuleCall_4_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractSequenceHint returns TypicalSizeHint
	 *     TypicalSizeHint returns TypicalSizeHint
	 *
	 * Constraint:
	 *     size=INT
	 */
	protected void sequence_TypicalSizeHint(ISerializationContext context, TypicalSizeHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdlPackage.Literals.TYPICAL_SIZE_HINT__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdlPackage.Literals.TYPICAL_SIZE_HINT__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypicalSizeHintAccess().getSizeINTTerminalRuleCall_4_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
}
